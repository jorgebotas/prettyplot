"""
Hatch patterns for prettyplot.

This module provides carefully curated hatch patterns with varying complexity
levels, optimized for distinguishing between categories in publication-ready
visualizations. The patterns are organized into three modes based on their
repetition and visual density.
"""

from typing import Dict, List, Optional


# =============================================================================
# Hatch Pattern Definitions
# =============================================================================

# Mode 1: Simple patterns (single repetition) - BASE PATTERNS
_HATCH_PATTERNS_SIMPLE: List[str] = [
    "",      # No hatch
    "/",     # Diagonal lines (forward)
    "\\",    # Diagonal lines (backward)
    ".",     # Dots
    "|",     # Vertical lines
    "-",     # Horizontal lines
    "+",     # Plus signs
    "x",     # Crosses
]
"""
Simple hatch patterns with single repetition (Mode 1).

Use case: Subtle pattern distinction suitable for small plot elements
or when patterns need to be minimal and unobtrusive.

These patterns provide the lightest visual density, making them ideal
for situations where you want to maintain visual clarity while still
providing categorical distinction.

Note: This is the base pattern definition. Medium and Dense patterns
are automatically generated by multiplying these patterns by 2 and 3.
"""

# Mode 2: Medium patterns (double repetition) - GENERATED FROM SIMPLE
_HATCH_PATTERNS_MEDIUM: List[str] = [pattern * 2 for pattern in _HATCH_PATTERNS_SIMPLE]
"""
Medium hatch patterns with double repetition (Mode 2).

Use case: Standard pattern density for most publication plots.
Provides good balance between visibility and aesthetic appeal.

This is the default mode (DEFAULT_HATCH_MODE = 2 in config.py),
offering patterns that are clearly distinguishable without being
overly dense or distracting.

Note: Automatically generated from _HATCH_PATTERNS_SIMPLE by
multiplying each pattern by 2.
"""

# Mode 3: Dense patterns (triple repetition) - GENERATED FROM SIMPLE
_HATCH_PATTERNS_DENSE: List[str] = [pattern * 3 for pattern in _HATCH_PATTERNS_SIMPLE]
"""
Dense hatch patterns with triple repetition (Mode 3).

Use case: High-density patterns for maximum distinction or when
patterns need to be highly visible (e.g., large plot elements,
presentations, or when printing in grayscale).

These patterns provide the strongest visual impact and are most
easily distinguished in challenging viewing conditions.

Note: Automatically generated from _HATCH_PATTERNS_SIMPLE by
multiplying each pattern by 3.
"""

# Mapping from mode to pattern list
_MODE_PATTERNS: Dict[int, List[str]] = {
    1: _HATCH_PATTERNS_SIMPLE,
    2: _HATCH_PATTERNS_MEDIUM,
    3: _HATCH_PATTERNS_DENSE,
}

# Global variable for current hatch mode (initialized lazily)
_CURRENT_HATCH_MODE: Optional[int] = None


def _get_default_mode() -> int:
    """Get the default hatch mode from config, with lazy loading."""
    from prettyplot import config
    return config.DEFAULT_HATCH_MODE


def _ensure_mode_initialized() -> None:
    """Ensure the current hatch mode is initialized."""
    global _CURRENT_HATCH_MODE
    if _CURRENT_HATCH_MODE is None:
        _CURRENT_HATCH_MODE = _get_default_mode()


# Global HATCH_PATTERNS variable (initialized as a copy of medium patterns)
HATCH_PATTERNS: List[str] = list(_HATCH_PATTERNS_MEDIUM)
"""
Current active hatch patterns based on the configured mode.

This list updates automatically when `set_hatch_mode()` is called.
By default, it uses the mode specified in config.DEFAULT_HATCH_MODE.

Note: To get the current patterns that reflect the mode setting, use
`get_hatch_patterns()` instead. This constant is provided for backward
compatibility and convenience.

Examples
--------
>>> import prettyplot as pp
>>> patterns = pp.get_hatch_patterns()
>>> print(patterns)
['', '//', '\\\\\\\\', '..', '||', '--', '++', 'xx']
"""


# =============================================================================
# Mode Management Functions
# =============================================================================

def set_hatch_mode(mode: int) -> None:
    """
    Set the global hatch pattern complexity mode.

    Changes the density of hatch patterns used throughout prettyplot.
    This affects all subsequent calls to `get_hatch_patterns()` and related
    functions that use hatch patterns.

    Parameters
    ----------
    mode : int
        Hatch pattern mode (1, 2, or 3):
        - 1: Simple patterns (single repetition, e.g., '/')
        - 2: Medium patterns (double repetition, e.g., '//') [default]
        - 3: Dense patterns (triple repetition, e.g., '///')

    Raises
    ------
    ValueError
        If mode is not 1, 2, or 3.

    Notes
    -----
    The mode setting persists for the entire session unless changed again.
    Mode 2 is the default and provides a good balance for most use cases.

    Use mode 1 for:
    - Subtle pattern distinction
    - Small plot elements
    - Minimalist aesthetics

    Use mode 2 for:
    - Standard publication plots
    - Balanced visibility and aesthetics
    - General-purpose visualizations

    Use mode 3 for:
    - Maximum pattern distinction
    - Large plot elements
    - Presentations or grayscale printing
    - High-visibility requirements

    Examples
    --------
    >>> import prettyplot as pp
    >>> # Use simple patterns
    >>> pp.set_hatch_mode(1)
    >>> fig, ax = pp.barplot(data=df, x='category', y='value', hue='group')

    >>> # Switch to dense patterns for better visibility
    >>> pp.set_hatch_mode(3)
    >>> fig, ax = pp.barplot(data=df, x='category', y='value', hue='group')

    >>> # Reset to default
    >>> pp.set_hatch_mode(2)

    See Also
    --------
    get_hatch_mode : Get the current hatch mode
    get_hatch_patterns : Get patterns for a specific mode
    """
    global _CURRENT_HATCH_MODE, HATCH_PATTERNS

    if mode not in _MODE_PATTERNS:
        raise ValueError(
            f"Invalid hatch mode: {mode}. Must be 1 (simple), "
            f"2 (medium), or 3 (dense)."
        )

    _CURRENT_HATCH_MODE = mode
    # Update HATCH_PATTERNS in place to maintain references
    HATCH_PATTERNS.clear()
    HATCH_PATTERNS.extend(_MODE_PATTERNS[mode])


def get_hatch_mode() -> int:
    """
    Get the current hatch pattern complexity mode.

    Returns
    -------
    int
        Current hatch mode (1, 2, or 3).

    Examples
    --------
    >>> import prettyplot as pp
    >>> mode = pp.get_hatch_mode()
    >>> print(f"Current mode: {mode}")
    Current mode: 2

    >>> pp.set_hatch_mode(3)
    >>> mode = pp.get_hatch_mode()
    >>> print(f"Current mode: {mode}")
    Current mode: 3

    See Also
    --------
    set_hatch_mode : Set the hatch pattern mode
    """
    _ensure_mode_initialized()
    return _CURRENT_HATCH_MODE


def get_hatch_patterns(mode: Optional[int] = None) -> List[str]:
    """
    Get hatch patterns for a specific mode.

    Returns the list of hatch patterns corresponding to the specified mode,
    or the current mode if no mode is specified.

    Parameters
    ----------
    mode : int, optional
        Hatch pattern mode (1, 2, or 3). If None, returns patterns for
        the current mode.

    Returns
    -------
    List[str]
        List of hatch pattern strings.

    Raises
    ------
    ValueError
        If mode is not None and not 1, 2, or 3.

    Examples
    --------
    >>> import prettyplot as pp
    >>> # Get patterns for current mode
    >>> patterns = pp.get_hatch_patterns()
    >>> print(patterns)
    ['', '//', '\\\\\\\\', '..', '||', '--', '++', 'xx']

    >>> # Get simple patterns without changing mode
    >>> simple = pp.get_hatch_patterns(mode=1)
    >>> print(simple)
    ['', '/', '\\\\', '.', '|', '-', '+', 'x']

    >>> # Get dense patterns
    >>> dense = pp.get_hatch_patterns(mode=3)
    >>> print(dense)
    ['', '///', '\\\\\\\\\\\\', '...', '|||', '---', '+++', 'xxx']

    See Also
    --------
    set_hatch_mode : Set the global hatch pattern mode
    get_hatch_mode : Get the current hatch mode
    """
    _ensure_mode_initialized()
    
    if mode is None:
        mode = _CURRENT_HATCH_MODE

    if mode not in _MODE_PATTERNS:
        raise ValueError(
            f"Invalid hatch mode: {mode}. Must be 1 (simple), "
            f"2 (medium), or 3 (dense)."
        )

    return _MODE_PATTERNS[mode].copy()


# =============================================================================
# Pattern Resolution Functions
# =============================================================================

def resolve_hatches(
    hatches: Optional[List[str]] = None,
    n_hatches: Optional[int] = None,
    reverse: bool = False,
) -> List[str]:
    """
    Resolve hatch patterns to a final list.

    This function provides flexible hatch pattern resolution for plotting
    functions. It can cycle through patterns, reverse order, and handle
    custom pattern lists.

    Parameters
    ----------
    hatches : List[str], optional
        List of hatch patterns. If None, uses the current global
        HATCH_PATTERNS based on the active mode.
    n_hatches : int, optional
        Number of hatch patterns to return. If specified and larger than
        the available patterns, cycles through the patterns. If None,
        returns all available patterns.
    reverse : bool, default False
        Whether to reverse the order of hatch patterns.

    Returns
    -------
    List[str]
        List of resolved hatch pattern strings.

    Notes
    -----
    - When n_hatches exceeds the number of available patterns, the function
      cycles through the patterns using modulo arithmetic.
    - The reverse operation is applied after cycling.
    - Empty string ('') represents no hatch pattern.

    Examples
    --------
    >>> import prettyplot as pp
    >>> # Get default patterns
    >>> patterns = pp.resolve_hatches()
    >>> print(patterns)
    ['', '//', '\\\\\\\\', '..', '||', '--', '++', 'xx']

    >>> # Get 5 patterns (cycles if needed)
    >>> patterns = pp.resolve_hatches(n_hatches=5)
    >>> print(patterns)
    ['', '//', '\\\\\\\\', '..', '||']

    >>> # Get 10 patterns with cycling
    >>> patterns = pp.resolve_hatches(n_hatches=10)
    >>> print(len(patterns))
    10

    >>> # Reverse pattern order
    >>> patterns = pp.resolve_hatches(n_hatches=4, reverse=True)
    >>> print(patterns)
    ['..', '\\\\\\\\', '//', '']

    >>> # Custom patterns
    >>> custom = ['/', 'x', '|']
    >>> patterns = pp.resolve_hatches(hatches=custom, n_hatches=5)
    >>> print(patterns)
    ['/', 'x', '|', '/', 'x']

    See Also
    --------
    resolve_hatch_mapping : Create value-to-hatch mappings
    get_hatch_patterns : Get patterns for a specific mode
    """
    if hatches is None:
        hatches = get_hatch_patterns()

    if n_hatches is not None:
        hatches = [hatches[i % len(hatches)] for i in range(n_hatches)]

    if reverse:
        hatches = hatches[::-1]

    return hatches


def resolve_hatch_mapping(
    values: Optional[List[str]] = None,
    hatch_mapping: Optional[Dict[str, str]] = None,
    reverse: bool = False,
) -> Dict[str, str]:
    """
    Resolve a hatch mapping from values to actual hatch patterns.

    Creates a dictionary mapping category values to hatch patterns.
    Useful for categorical plots where different categories need
    distinct hatch patterns.

    Parameters
    ----------
    values : List[str], optional
        List of category values to map to hatch patterns.
        If None, returns an empty dictionary.
    hatch_mapping : Dict[str, str] or List[str], optional
        Hatch pattern specification:
        - None: Uses current global HATCH_PATTERNS
        - dict: Custom mapping from values to patterns (returned as-is)
        - list: List of hatch patterns to map to values
    reverse : bool, default False
        Whether to reverse the pattern order before mapping.
        Only applies when hatch_mapping is None or a list.

    Returns
    -------
    Dict[str, str]
        Dictionary mapping values to hatch pattern strings.

    Notes
    -----
    - If hatch_mapping is already a dictionary, it's returned unchanged.
    - If values is None, returns an empty dictionary.
    - Patterns cycle if there are more values than patterns.

    Examples
    --------
    >>> import prettyplot as pp
    >>> # Create mapping for categories
    >>> values = ['A', 'B', 'C', 'D']
    >>> mapping = pp.resolve_hatch_mapping(values)
    >>> print(mapping)
    {'A': '', 'B': '//', 'C': '\\\\\\\\', 'D': '..'}

    >>> # Custom pattern mapping
    >>> custom_patterns = ['/', 'x', '|']
    >>> mapping = pp.resolve_hatch_mapping(values, hatch_mapping=custom_patterns)
    >>> print(mapping)
    {'A': '/', 'B': 'x', 'C': '|', 'D': '/'}

    >>> # Pre-defined mapping
    >>> custom_mapping = {'A': '///', 'B': 'xxx', 'C': '...', 'D': '|||'}
    >>> mapping = pp.resolve_hatch_mapping(values, hatch_mapping=custom_mapping)
    >>> print(mapping)
    {'A': '///', 'B': 'xxx', 'C': '...', 'D': '|||'}

    >>> # Reversed pattern order
    >>> mapping = pp.resolve_hatch_mapping(values, reverse=True)
    >>> print(mapping)
    {'A': 'xx', 'B': '++', 'C': '--', 'D': '||'}

    See Also
    --------
    resolve_hatches : Resolve hatch pattern lists
    """
    if values is None:
        return {}

    if isinstance(hatch_mapping, dict):
        return hatch_mapping

    hatches = resolve_hatches(hatch_mapping, n_hatches=len(values), reverse=reverse)
    return {value: hatch for value, hatch in zip(values, hatches)}


# =============================================================================
# Display Functions
# =============================================================================

def list_hatch_modes() -> Dict[int, str]:
    """
    List all available hatch modes with descriptions.

    Returns
    -------
    Dict[int, str]
        Dictionary mapping mode numbers to their descriptions.

    Examples
    --------
    >>> import prettyplot as pp
    >>> modes = pp.list_hatch_modes()
    >>> for mode, desc in modes.items():
    ...     print(f"Mode {mode}: {desc}")
    Mode 1: Simple patterns (single repetition)
    Mode 2: Medium patterns (double repetition)
    Mode 3: Dense patterns (triple repetition)

    See Also
    --------
    get_hatch_mode : Get the current hatch mode
    set_hatch_mode : Set the hatch pattern mode
    """
    return {
        1: "Simple patterns (single repetition)",
        2: "Medium patterns (double repetition)",
        3: "Dense patterns (triple repetition)",
    }


def show_hatch_patterns(mode: Optional[int] = None) -> None:
    """
    Display hatch patterns visually for a given mode.

    Prints the hatch patterns for the specified mode (or current mode)
    to the console with visual representation using Unicode characters.

    Parameters
    ----------
    mode : int, optional
        Hatch pattern mode (1, 2, or 3). If None, uses current mode.

    Examples
    --------
    >>> import prettyplot as pp
    >>> # Show current mode patterns
    >>> pp.show_hatch_patterns()
    Hatch Patterns (Mode 2 - Medium patterns):
    0: '' (no pattern)
    1: '//'
    2: '\\\\\\\\'
    3: '..'
    4: '||'
    5: '--'
    6: '++'
    7: 'xx'

    >>> # Show patterns for a specific mode
    >>> pp.show_hatch_patterns(mode=1)
    Hatch Patterns (Mode 1 - Simple patterns):
    0: '' (no pattern)
    1: '/'
    2: '\\\\'
    3: '.'
    4: '|'
    5: '-'
    6: '+'
    7: 'x'

    See Also
    --------
    list_hatch_modes : List all available modes
    get_hatch_patterns : Get patterns for a mode
    """
    if mode is None:
        mode = get_hatch_mode()

    mode_descriptions = list_hatch_modes()
    if mode not in mode_descriptions:
        raise ValueError(
            f"Invalid hatch mode: {mode}. Must be 1, 2, or 3."
        )

    patterns = get_hatch_patterns(mode)
    mode_desc = mode_descriptions[mode]

    print(f"\nHatch Patterns (Mode {mode} - {mode_desc}):")
    print("-" * 50)
    for i, pattern in enumerate(patterns):
        if pattern == "":
            display = "'' (no pattern)"
        else:
            display = f"'{pattern}'"
        print(f"{i}: {display}")
    print()


# Initialize the mode on first import
_ensure_mode_initialized()
